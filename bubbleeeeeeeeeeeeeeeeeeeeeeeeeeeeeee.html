<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â§¢ÂπªÊ≥°Ê≥°ÂØ¶È©óÂÆ§ - Â∞àÊ•≠Áâà</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Noto Sans TC', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: crosshair;
        }

        /* UI Â±§ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #start-hint {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.2rem;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* ÂàùÂßãÈö±ËóèÂ∑•ÂÖ∑Âàó */
        .toolbar {
            display: none; /* ÂàùÂßã‰∏çÈ°ØÁ§∫ */
            justify-content: center;
            gap: 15px;
            padding: 20px;
            pointer-events: auto;
            opacity: 0;
            transform: translateY(-50px);
            transition: all 0.5s ease-out;
        }

        .tool-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: rgba(100, 200, 255, 0.4);
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.4);
        }

        /* ÂàùÂßãÈö±ËóèÊéßÂà∂Ëâô */
        .cockpit {
            display: none; /* ÂàùÂßã‰∏çÈ°ØÁ§∫ */
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            color: white;
            pointer-events: auto;
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.5s ease-out;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .cockpit h3 {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
            color: #aaddff;
        }

        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #ddd;
        }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px; border-radius: 50%;
            background: #ffffff; cursor: pointer; margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px;
        }

        /* ÂïüÂãïÂæåÈ°ØÁ§∫ÁöÑÁãÄÊÖã */
        .game-active .toolbar {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }
        
        .game-active .cockpit {
            display: block;
            opacity: 1;
            transform: translateX(0);
        }
        
        .game-active #start-hint { opacity: 0; }

        @media (max-width: 600px) {
            .cockpit { width: calc(100% - 40px); left: 10px; right: 10px; }
            .toolbar { flex-wrap: wrap; gap: 5px; }
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="bubbleCanvas"></canvas>
    </div>

    <div id="ui-layer">
        <div id="start-hint">Êà≥Á†¥Ê≥°Ê≥°ÈñãÂßãÂêπÊ∞£‰πãÊóÖ</div>

        <div class="toolbar" id="toolbar">
            <button class="tool-btn" onclick="selectTool(0)">üî´ Ê≥°Ê≥°Ê©ü</button>
            <button class="tool-btn" onclick="selectTool(1)">‚úã ÊâãÊâã</button>
            <button class="tool-btn" onclick="selectTool(2)">üß≤ MÂûãÂ§æ(Á∂ìÂÖ∏)</button>
        </div>

        <div class="cockpit" id="cockpit">
            <h3>Áí∞Â¢ÉÊéßÂà∂Ëâô</h3>
            <div class="control-group">
                <label>È¢®ÈÄü (Wind) <span id="val-wind">2</span></label>
                <input type="range" min="-10" max="10" value="2" step="0.5" id="range-wind">
            </div>
            <div class="control-group">
                <label>ÊäòÂ∞ÑËßíÂ∫¶ (Light) <span id="val-light">45¬∞</span></label>
                <input type="range" min="0" max="360" value="45" id="range-light">
            </div>
            <div class="control-group">
                <label>Ê≥°Ê≥°ÈüåÊÄß (Life) <span id="val-life">‰∏≠</span></label>
                <input type="range" min="50" max="500" value="200" id="range-life">
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('bubbleCanvas');
        const ctx = canvas.getContext('2d');
        
        const STATE = { START_SCREEN: 0, PLAYING: 1 };
        let currentState = STATE.START_SCREEN;

        const TOOLS = { GUN: 0, HAND: 1, WAND: 2 };
        let currentTool = TOOLS.GUN;

        let env = { wind: 2, lightAngle: 45, bubbleLife: 200, gravity: -0.05 };
        let pointer = { x: 0, y: 0, isDown: false, downStart: 0, startX: 0, startY: 0 };
        let width, height, bubbles = [], particles = [], startBubble = null;

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.color = color;
                this.size = Math.random() * 2 + 1;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += 0.2; this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Bubble {
            constructor(x, y, radius, vx, vy) {
                this.x = x; this.y = y;
                this.radius = radius;
                this.vx = vx; this.vy = vy;
                this.maxLife = env.bubbleLife + Math.random() * 100;
                this.age = 0;
                this.popping = false;
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.1 + Math.random() * 0.1;
                this.wobbleAmp = 0.2;
                this.hueOffset = Math.random() * 360;
            }
            update() {
                this.age++;
                this.x += this.vx; this.y += this.vy;
                this.vx += (env.wind * 0.01);
                this.vx *= 0.99;
                this.vy += env.gravity;
                this.vy *= 0.99;
                this.wobbleAmp *= 0.98;
                if (this.x < -this.radius * 2 || this.x > width + this.radius * 2 || this.y < -100) {
                    this.popping = true;
                }
            }
            draw(ctx) {
                if (this.popping) return;
                const wobble = Math.sin(this.age * this.wobbleSpeed + this.wobblePhase) * this.wobbleAmp;
                const rx = this.radius * (1 + wobble);
                const ry = this.radius * (1 - wobble);
                const rotation = this.vx * 0.1;

                let alpha = 1;
                let grayness = 0;
                const lifePercent = this.age / this.maxLife;
                if (lifePercent > 0.8) {
                    alpha = 1 - ((lifePercent - 0.8) * 5); 
                    grayness = (lifePercent - 0.8) * 5;
                }
                if (lifePercent >= 1) { this.pop(); return; }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(rotation);
                ctx.beginPath();
                ctx.ellipse(0, 0, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);

                const lightHue = (env.lightAngle + this.age + this.hueOffset) % 360;
                const gradient = ctx.createRadialGradient(-rx*0.3, -ry*0.3, rx*0.1, 0, 0, rx);
                const sat = 100 * (1 - grayness);
                gradient.addColorStop(0, `hsla(0,0%,100%,0)`);
                gradient.addColorStop(0.8, `hsla(${lightHue}, ${sat}%, 50%, ${0.1 * alpha})`);
                gradient.addColorStop(1, `hsla(${lightHue+40}, ${sat}%, 50%, ${0.3 * alpha})`);

                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = `hsla(${lightHue}, ${sat}%, 80%, ${0.4 * alpha})`;
                ctx.stroke();
                ctx.restore();
            }
            pop() {
                this.popping = true;
                const count = 6 + Math.floor(this.radius / 5);
                for (let i = 0; i < count; i++) particles.push(new Particle(this.x, this.y, 'rgba(200, 230, 255, 0.8)'));
            }
        }

        class StartBubble extends Bubble {
            constructor(x, y) { super(x, y, 80, 0, 0); this.maxLife = Infinity; }
            draw(ctx) {
                if (this.popping) return;
                super.draw(ctx);
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = "white";
                ctx.font = "bold 30px 'Noto Sans TC'";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("START", 0, 0);
                ctx.font = "14px 'Noto Sans TC'";
                ctx.fillText("Êà≥Á†¥ÊàëÈñãÂßã", 0, 30);
                ctx.restore();
            }
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);
            resetStartBubble();

            canvas.addEventListener('mousedown', handlePointerDown);
            window.addEventListener('mouseup', handlePointerUp);
            canvas.addEventListener('mousemove', handlePointerMove);
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handlePointerDown(e.touches[0]);
            }, {passive: false});
            window.addEventListener('touchend', handlePointerUp);
            canvas.addEventListener('touchmove', (e) => {
                handlePointerMove(e.touches[0]);
            }, {passive: false});

            setupUI();
            requestAnimationFrame(loop);
        }

        function setupUI() {
            document.getElementById('range-wind').addEventListener('input', (e) => {
                env.wind = parseFloat(e.target.value);
                document.getElementById('val-wind').innerText = env.wind;
            });
            document.getElementById('range-light').addEventListener('input', (e) => {
                env.lightAngle = parseInt(e.target.value);
                document.getElementById('val-light').innerText = env.lightAngle + "¬∞";
            });
            document.getElementById('range-life').addEventListener('input', (e) => {
                env.bubbleLife = parseInt(e.target.value);
                let txt = env.bubbleLife > 350 ? "Èï∑" : (env.bubbleLife > 150 ? "‰∏≠" : "Áü≠");
                document.getElementById('val-life').innerText = txt;
            });
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (startBubble) { startBubble.x = width / 2; startBubble.y = height / 2; }
        }

        function resetStartBubble() { startBubble = new StartBubble(width / 2, height / 2); }

        function handlePointerDown(e) {
            pointer.x = e.clientX;
            pointer.y = e.clientY;
            pointer.isDown = true;
            pointer.downStart = Date.now();

            if (currentState === STATE.START_SCREEN) {
                const dx = pointer.x - startBubble.x;
                const dy = pointer.y - startBubble.y;
                if (Math.sqrt(dx*dx + dy*dy) < startBubble.radius) {
                    startBubble.pop();
                    setTimeout(startGame, 300);
                }
            } else if (currentTool === TOOLS.WAND) {
                pointer.startX = pointer.x;
                pointer.startY = pointer.y;
            }
        }

        function handlePointerMove(e) {
            pointer.x = e.clientX;
            pointer.y = e.clientY;
        }

        function handlePointerUp() {
            if (!pointer.isDown) return;
            pointer.isDown = false;
            if (currentState === STATE.PLAYING && currentTool === TOOLS.WAND) {
                fireWandBubble();
            }
        }

        function startGame() {
            currentState = STATE.PLAYING;
            document.body.classList.add('game-active');
            selectTool(0);
        }

        window.selectTool = function(idx) {
            currentTool = idx;
            document.querySelectorAll('.tool-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === idx);
            });
        }

        function updateTools() {
            if (!pointer.isDown) return;
            if (currentTool === TOOLS.GUN) {
                if (Date.now() % 100 < 20) {
                    spawnBubble(pointer.x - 20, pointer.y, 10 + Math.random() * 5);
                    spawnBubble(pointer.x + 20, pointer.y, 10 + Math.random() * 5);
                }
            } else if (currentTool === TOOLS.HAND) {
                if (Date.now() % 500 < 20) {
                    spawnBubble(pointer.x, pointer.y, 30 + Math.random() * 15);
                }
            }
        }

        function fireWandBubble() {
            const dx = pointer.x - pointer.startX;
            const dy = pointer.y - pointer.startY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 10) return;

            let radius = Math.min(dist * 0.4, 180); 
            const vx = -dx * 0.15 + (env.wind * 2);
            const vy = -dy * 0.15;

            const b = new Bubble(pointer.x, pointer.y, radius, vx, vy);
            b.wobbleAmp = 0.5; 
            bubbles.push(b);
        }

        function spawnBubble(x, y, r) {
            const vx = (Math.random() - 0.5) * 2 + (env.wind * 0.5);
            const vy = (Math.random() - 0.5) * 2 - 2;
            bubbles.push(new Bubble(x, y, r, vx, vy));
        }

        function drawWandVisuals() {
            if (currentState === STATE.PLAYING && currentTool === TOOLS.WAND && pointer.isDown) {
                ctx.save();
                const grad = ctx.createLinearGradient(pointer.startX, pointer.startY, pointer.x, pointer.y);
                grad.addColorStop(0, "rgba(255, 255, 255, 0.5)");
                grad.addColorStop(0.5, "rgba(100, 200, 255, 0.3)");
                grad.addColorStop(1, "rgba(255, 255, 255, 0.1)");
                
                ctx.beginPath();
                ctx.moveTo(pointer.startX - 40, pointer.startY);
                ctx.lineTo(pointer.x, pointer.y);
                ctx.lineTo(pointer.startX + 40, pointer.startY);
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.6)";
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = "#fff";
                ctx.beginPath();
                ctx.arc(pointer.startX - 40, pointer.startY, 8, 0, Math.PI*2);
                ctx.arc(pointer.startX + 40, pointer.startY, 8, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
        }

        function loop() {
            ctx.clearRect(0, 0, width, height);
            if (currentState === STATE.START_SCREEN) {
                if (startBubble) { startBubble.update(); startBubble.draw(ctx); }
            } else {
                updateTools();
                drawWandVisuals();
            }

            for (let i = bubbles.length - 1; i >= 0; i--) {
                bubbles[i].update(); bubbles[i].draw(ctx);
                if (bubbles[i].popping) bubbles.splice(i, 1);
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(); particles[i].draw(ctx);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(loop);
        }

        init();
    </script>
</body>
</html>
