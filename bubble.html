<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>Bubble World</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, #eef6ff, #f9fbff);
    overflow: hidden;
  }
  canvas {
    display: block;
    background: transparent;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
  console.log("我是12281218版本！");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();
  
  let bubbles = [];
  let wind = 0.15;
  
  class Bubble {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.r = Math.random() * 25 + 20;
      this.life = 1;
      this.vy = Math.random() * -0.3 - 0.2;
      this.vx = (Math.random() - 0.5) * 0.2;
      this.t = Math.random() * 1000;
      this.angle = Math.random() * Math.PI * 2;
      this.blur = 0;
      this.edgeSpread = 0;
    }
  
    update() {
      this.x += Math.sin(this.t * 2) * 0.05 + this.vx + wind;
      this.y += this.vy;
      this.t += 0.006;
      this.life -= 0.003; // 壽命縮短
      if (this.life < 0.3) {
        this.blur = (0.3 - this.life) * 10;       // 模糊
        this.edgeSpread = (0.3 - this.life) * 15; // 邊緣擴散
      }
      this.angle += 0.02; // 油墨旋轉
    }
  
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.globalAlpha = this.life;
      ctx.filter = `blur(${this.blur || 0}px)`;
  
      // 中心高光
      const innerGrad = ctx.createRadialGradient(0,0,0,0,0,this.r);
      innerGrad.addColorStop(0, "rgba(255,255,255,0.025)");
      innerGrad.addColorStop(0.6, "rgba(255,255,255,0.015)");
      innerGrad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = innerGrad;
      ctx.beginPath();
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.fill();
  
      // 彩色漸層旋轉（油墨流動）
      for (let i=0; i<5; i++){
        const a = this.t + i*1.3 + this.angle;
        const grad = ctx.createRadialGradient(
          Math.cos(a)*this.r*0.25,
          Math.sin(a)*this.r*0.25,
          this.r*0.1,
          0,0,this.r
        );
        grad.addColorStop(0, `hsla(${(this.t*40 + i*70)%360}, 80%, 70%, 0.25)`);
        grad.addColorStop(0.6, `hsla(${(this.t*40 + i*70 + 120)%360}, 80%, 65%, 0.15)`);
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0,0,this.r,0,Math.PI*2);
        ctx.fill();
      }
  
      // 小反光高光
      const hx = -this.r*0.25, hy = -this.r*0.3;
      const highlight = ctx.createRadialGradient(hx, hy, 0, hx, hy, this.r*0.6);
      highlight.addColorStop(0,"rgba(255,255,255,0.35)");
      highlight.addColorStop(0.3,"rgba(255,255,255,0.15)");
      highlight.addColorStop(1,"rgba(255,255,255,0)");
      ctx.fillStyle = highlight;
      ctx.beginPath();
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.fill();
  
      // 邊緣淡出
      const edgeFade = Math.max(this.life,0);
      ctx.strokeStyle = `rgba(255,255,255,${0.25*edgeFade})`;
      ctx.lineWidth = 0.4 + (1-edgeFade)*1.2;
      ctx.beginPath();
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.stroke();
  
      // 邊緣擴散（破裂效果）
      if(this.edgeSpread > 0){
        const edgeGrad = ctx.createRadialGradient(0,0,this.r, 0,0,this.r + this.edgeSpread);
        edgeGrad.addColorStop(0, "rgba(255,255,255,0)");
        edgeGrad.addColorStop(1, `rgba(255,255,255,${0.1*this.life})`);
        ctx.fillStyle = edgeGrad;
        ctx.beginPath();
        ctx.arc(0,0,this.r + this.edgeSpread, 0, Math.PI*2);
        ctx.fill();
      }
  
      ctx.filter = "none";
      ctx.restore();
    }
  }
  
  function loop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    bubbles.forEach((b,i)=>{
      b.update();
      b.draw();
      if(b.life<=0) bubbles.splice(i,1);
    });
    requestAnimationFrame(loop);
  }
  loop();
  
  function spawn(x,y){
    bubbles.push(new Bubble(x,y));
  }
  
  canvas.addEventListener("mousedown", e=>spawn(e.clientX, e.clientY));
  canvas.addEventListener("touchstart", e=>{
    const t = e.touches[0];
    spawn(t.clientX, t.clientY);
  });
</script>
</body>
</html>
